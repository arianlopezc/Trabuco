# Build & Test Commands

```bash
mvn clean compile                # Compile all modules
mvn clean install                # Build and install to local repo
mvn test                         # Run all tests
mvn test -pl Model               # Test single module
{{- if .HasModule "API"}}
mvn spring-boot:run -pl API      # Run API (port 8080)
{{- end}}
{{- if .HasModule "Worker"}}
mvn spring-boot:run -pl Worker   # Run Worker (dashboard at port 8000)
{{- end}}
{{- if .HasModule "SQLDatastore"}}
mvn flyway:migrate -pl SQLDatastore  # Run migrations manually
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
mvn test -pl NoSQLDatastore      # Run NoSQL repository tests (requires Docker)
{{- end}}
```

# Immutables - IMPORTANT

This project uses [Immutables](https://immutables.github.io/) for all DTOs and entities.

**Always prefer:**
- `ImmutableX` concrete types over interface types in method signatures
- Builder pattern for object creation: `ImmutablePlaceholder.builder()...build()`
- Never use `new` for Immutable objects, always use builders

**Example - CORRECT:**
```java
public ImmutablePlaceholder create(ImmutablePlaceholderRequest request) {
    return ImmutablePlaceholder.builder()
        .name(request.name())
        .description(request.description())
        .build();
}
```

**Example - AVOID:**
```java
public Placeholder create(PlaceholderRequest request) {  // Don't use interface types
    return Placeholder.fromRecord(record);  // Don't use factory methods
}
```

{{- if .HasModule "SQLDatastore"}}

**Database persistence:**
- Use `PlaceholderRecord` (Java record) only at the repository boundary
- Convert to `ImmutablePlaceholder` immediately after repository calls
- Never expose `PlaceholderRecord` outside the repository/service layer
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}

**NoSQL persistence:**
- Use `PlaceholderDocument` (Java record) only at the repository boundary
- Convert to `ImmutablePlaceholder` immediately after repository calls
- Never expose `PlaceholderDocument` outside the repository/service layer
{{- if eq .NoSQLDatabase "mongodb"}}
- MongoDB auto-generates `_id` when `id` is null on save
{{- else if eq .NoSQLDatabase "redis"}}
- Redis auto-generates `id` when null on save (uses UUID)
{{- end}}
{{- end}}

# Code Style

- Use Immutables for all DTOs and entities: `@Value.Immutable` + `@ImmutableStyle`
- Always add `@JsonSerialize` and `@JsonDeserialize` annotations for Jackson
- Enums do NOT use Immutables (they're already immutable)
{{- if .HasModule "SQLDatastore"}}
- Spring Data JDBC (not JPA) - no lazy loading, no proxies
- Flyway migrations: `V{number}__{description}.sql`
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
{{- if eq .NoSQLDatabase "mongodb"}}
- Spring Data MongoDB with `@Document` annotation on entities
- Use `@Indexed` for fields that need secondary indexes
{{- else if eq .NoSQLDatabase "redis"}}
- Spring Data Redis with `@RedisHash` annotation on entities
- Use `@Indexed` for fields that need secondary indexes
{{- end}}
{{- end}}
{{- if .HasModule "Shared"}}
- Use `@CircuitBreaker(name = "default")` on service methods that call external resources
{{- end}}

# Workflow

- Run `mvn clean compile` after code changes to verify build
{{- if .HasModule "SQLDatastore"}}
- Create new migration files for any schema changes (never modify existing migrations)
- Repository tests use Testcontainers - Docker must be running
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
- Repository tests use Testcontainers - Docker must be running
{{- if eq .NoSQLDatabase "mongodb"}}
- MongoDB collections are created automatically on first document insert
{{- else if eq .NoSQLDatabase "redis"}}
- Redis keys are created automatically on first save
{{- end}}
{{- end}}
{{- if .HasModule "API"}}
- Validate request DTOs with Jakarta annotations (@NotBlank, @Size, etc.)
{{- end}}
{{- if .HasModule "Worker"}}

# Background Jobs (JobRunr)

JobRunr provides four types of background jobs. All jobs are persisted to the database, automatically retried on failure, and distributed across Worker instances.

**Fire-and-forget** - Execute immediately in background:
```java
jobScheduler.<MyJobService>enqueue(job -> job.processData(data));
```

**Delayed** - Execute at a specific time:
```java
Instant executeAt = Instant.now().plus(1, ChronoUnit.HOURS);
jobScheduler.<MyJobService>schedule(executeAt, job -> job.processData(data));
```

**Recurring** - Execute on a CRON schedule (register in RecurringJobsConfig):
```java
jobScheduler.scheduleRecurrently("cleanup-job", Cron.daily(),
    () -> cleanupService.runCleanup());
```

**Batch** - Process multiple items efficiently:
```java
jobScheduler.<MyJobService, String>enqueue(
    items.stream(),
    MyJobService::processItem
);
```

**Job method requirements:**
- Annotate with `@Job(name = "Descriptive name: %0")` (use %0, %1 for params)
- Keep job methods simple and idempotent (they may retry on failure)
- Inject dependencies via constructor, not method parameters

**Dashboard:** http://localhost:8000 (when Worker is running)
{{- end}}
