# {{.ProjectName}}

Java multi-module Maven project using Spring Boot{{if .HasModule "SQLDatastore"}} with {{if eq .Database "postgresql"}}PostgreSQL{{else if eq .Database "mysql"}}MySQL{{end}}{{end}}{{if .HasModule "NoSQLDatastore"}}{{if .HasModule "SQLDatastore"}} and{{else}} with{{end}} {{if eq .NoSQLDatabase "mongodb"}}MongoDB{{else if eq .NoSQLDatabase "redis"}}Redis{{end}}{{end}}{{if .HasModule "Worker"}} and JobRunr for background jobs{{end}}{{if .HasModule "EventConsumer"}} and {{if .UsesKafka}}Kafka{{else if .UsesRabbitMQ}}RabbitMQ{{end}} for event-driven processing{{end}}.

## Immutables

This project uses [Immutables](https://immutables.github.io/) for all DTOs and entities. This is a critical pattern — Claude must follow it.

**Rules:**
- Always use `ImmutableX` concrete types in method signatures, not interface types
- Always use builders: `ImmutablePlaceholder.builder()...build()`
- Never use `new` for Immutable objects
- Always add `@JsonSerialize` and `@JsonDeserialize` annotations
- Enums do NOT use Immutables

**Correct:**
```java
public ImmutablePlaceholder create(ImmutablePlaceholderRequest request) {
    return ImmutablePlaceholder.builder()
        .name(request.name())
        .build();
}
```

**Wrong:**
```java
public Placeholder create(PlaceholderRequest request) {  // interface type
    return new Placeholder(...);  // constructor
}
```
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}

## Persistence Boundaries
{{- if .HasModule "SQLDatastore"}}

**SQL (Spring Data JDBC):**
- `PlaceholderRecord` (Java record) exists only at repository boundary
- Convert to `ImmutablePlaceholder` immediately after repository calls
- Never expose `PlaceholderRecord` outside repository/service layer
- Flyway migrations: `V{number}__{description}.sql` — never modify existing migrations
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}

**NoSQL ({{if eq .NoSQLDatabase "mongodb"}}MongoDB{{else if eq .NoSQLDatabase "redis"}}Redis{{end}}):**
- `PlaceholderDocument` (Java record) exists only at repository boundary
- Convert to `ImmutablePlaceholder` immediately after repository calls
- Never expose `PlaceholderDocument` outside repository/service layer
{{- if eq .NoSQLDatabase "mongodb"}}
- MongoDB auto-generates `_id` when `id` is null on save
{{- else if eq .NoSQLDatabase "redis"}}
- Redis auto-generates `id` when null on save (uses UUID)
{{- end}}
{{- end}}
{{- end}}
{{- if .HasModule "API"}}

## Exception Handling

`GlobalExceptionHandler` handles all common exceptions — do not add try-catch in controllers for:
- Validation errors (400)
- JSON parsing errors (400)
- Missing/mistyped parameters (400)
- Not found (404)
- Method not allowed (405)
- Unsupported media type (415)
- Uncaught exceptions (500)
{{- end}}
{{- if .HasModule "Worker"}}

## Background Jobs (JobRunr)

**Architecture:**
- `Jobs` module contains `JobRequest` records (data contracts)
- `Worker` module contains `JobRequestHandler` implementations
- Any module can enqueue jobs by depending on Jobs module
- Handler class name must be `{RequestName}Handler`

**Enqueueing jobs:**
```java
// Fire-and-forget
BackgroundJobRequest.enqueue(new ProcessPlaceholderJobRequest("data"));

// Delayed
BackgroundJobRequest.schedule(Instant.now().plus(1, ChronoUnit.HOURS),
    new ProcessPlaceholderJobRequest("data"));

// Batch
BackgroundJobRequest.enqueue(requests.stream());
```

**Recurring jobs:** Register in `RecurringJobsConfig` using `jobScheduler.scheduleRecurrently()`

**Handler requirements:**
- Annotate with `@Job(name = "Descriptive name: %0")`
- Keep handlers idempotent (they retry on failure)

**Ports:**
- 8081 — Worker application
- 8082 — Management/actuator (health checks use this port, not 8081)
- 8000 — JobRunr Dashboard (no auth by default — disable in production)
{{- end}}
{{- if .HasModule "EventConsumer"}}

## Event-Driven Processing ({{if .UsesKafka}}Kafka{{else if .UsesRabbitMQ}}RabbitMQ{{end}})

**Architecture:**
- `Events` module contains sealed interfaces for event contracts
- `EventConsumer` module contains event listeners
- `Shared` module contains `EventPublisher` for publishing events

**Event contracts (Events module):**
```java
public sealed interface PlaceholderEvent
    permits PlaceholderCreatedEvent {
    String eventId();
    Instant occurredAt();
}
```

**Publishing events (from Shared/API):**
```java
@Autowired
private EventPublisher eventPublisher;

eventPublisher.publish("placeholder-events", PlaceholderCreatedEvent.create("123", "name"));
```

**Listener pattern:**
{{- if .UsesKafka}}
- Use `@RetryableTopic` with DLT suffix for dead letter queue
- Use `@KafkaListener` with topics from `${app.kafka.topics.xxx}`
{{- else if .UsesRabbitMQ}}
- Use `@RabbitListener` with queue names from `${app.rabbitmq.queues.xxx}`
- Dead letter exchange is configured automatically with `.dlx` suffix
{{- end}}

**Ports:**
- 8083 — EventConsumer application
- 8084 — Management/actuator (health checks use this port, not 8083)
{{- end}}

## Configuration
{{- if or (or (.HasModule "API") (.HasModule "Worker")) (.HasModule "EventConsumer")}}

- Use `${ENV_VAR:default}` pattern in `application.yml` — never hardcode credentials
- Log format is in `logback-spring.xml`, log levels are in `application.yml` — do not mix these
- Default profile is `local` (colored console); other profiles use JSON logging
{{- end}}
{{- if .HasModule "Shared"}}
- Use `@CircuitBreaker(name = "default")` on methods calling external resources
{{- end}}
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}

## Testing

Repository tests use Testcontainers — Docker must be running.
{{- end}}

## Git

These files are local and already in `.gitignore`:
- `CLAUDE.local.md`, `.claude/settings.local.json` — personal Claude Code settings
- `*PLAN.md` — plan mode scratch files
