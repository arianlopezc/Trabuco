# {{.ProjectName}}

Java multi-module Maven project using Spring Boot{{if .HasModule "SQLDatastore"}} with {{if eq .Database "postgresql"}}PostgreSQL{{else if eq .Database "mysql"}}MySQL{{end}}{{end}}{{if .HasModule "NoSQLDatastore"}}{{if .HasModule "SQLDatastore"}} and{{else}} with{{end}} {{if eq .NoSQLDatabase "mongodb"}}MongoDB{{else if eq .NoSQLDatabase "redis"}}Redis{{end}}{{end}}{{if .HasModule "Worker"}} and JobRunr for background jobs{{end}}{{if .HasModule "EventConsumer"}} and {{if .UsesKafka}}Kafka{{else if .UsesRabbitMQ}}RabbitMQ{{else if .UsesSQS}}AWS SQS{{else if .UsesPubSub}}GCP Pub/Sub{{end}} for event-driven processing{{end}}.

<!-- AI:COMMANDS:START -->
## Build & Test Commands

| Command | Description |
|---------|-------------|
| `mvn clean compile` | Build all modules |
| `mvn test` | Run all tests |
| `mvn clean package` | Package all modules |
{{- if .HasModule "API"}}
| `cd API && mvn spring-boot:run` | Start API server (port 8080) |
{{- end}}
{{- if .HasModule "Worker"}}
| `cd Worker && mvn spring-boot:run` | Start Worker (port 8081) |
{{- end}}
{{- if .HasModule "EventConsumer"}}
| `cd EventConsumer && mvn spring-boot:run` | Start EventConsumer (port 8083) |
{{- end}}
{{- if or (or (.HasModule "API") (.HasModule "Worker")) (.HasModule "EventConsumer")}}
| `docker-compose up -d` | Start infrastructure services |
{{- end}}
<!-- AI:COMMANDS:END -->
{{- if or (or (.HasModule "API") (.HasModule "Worker")) (.HasModule "EventConsumer")}}

**Docker:**
```bash
{{- if .HasModule "API"}}
docker build -f API/Dockerfile -t {{.ProjectName}}-api .
{{- end}}
{{- if .HasModule "Worker"}}
docker build -f Worker/Dockerfile -t {{.ProjectName}}-worker .
{{- end}}
{{- if .HasModule "EventConsumer"}}
docker build -f EventConsumer/Dockerfile -t {{.ProjectName}}-eventconsumer .
{{- end}}
```
{{- end}}

<!-- AI:PATTERNS:START -->
## Code Patterns

| Pattern | Description |
|---------|-------------|
| Entities | Use `ImmutableX.builder()...build()` pattern with `@Value.Immutable` |
| DTOs | Use `@Value.Immutable` with `@JsonSerialize/@JsonDeserialize` |
{{- if .HasModule "Shared"}}
| Services | Inject repositories, add `@CircuitBreaker(name = "default")` on external calls |
{{- end}}
{{- if .HasModule "API"}}
| Controllers | Use `@RestController`, return `ImmutableXResponse` types |
{{- end}}
{{- if .HasModule "SQLDatastore"}}
| SQL Records | Use Java records at repository boundary, convert to Immutables immediately |
| Migrations | Use `V{number}__{description}.sql`, never modify existing migrations |
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
| NoSQL Documents | Use Java records at repository boundary, convert to Immutables immediately |
{{- end}}
{{- if .HasModule "Worker"}}
| Job Handlers | Annotate with `@Job(name = "Description: %0")`, keep idempotent |
{{- end}}
{{- if .HasModule "EventConsumer"}}
| Event Listeners | Use sealed interfaces for event contracts, handle DLT for failures |
{{- end}}
<!-- AI:PATTERNS:END -->

<!-- AI:FILES:START -->
## File Locations

| Purpose | Location |
|---------|----------|
{{- if .HasModule "Model"}}
| Entities | `Model/src/main/java/.../model/entities/` |
| DTOs | `Model/src/main/java/.../model/dto/` |
| Events (schemas) | `Model/src/main/java/.../model/events/` |
| Jobs (schemas) | `Model/src/main/java/.../model/jobs/` |
{{- end}}
{{- if .HasModule "SQLDatastore"}}
| SQL Repositories | `SQLDatastore/src/main/java/.../sqldatastore/repository/` |
| SQL Migrations | `SQLDatastore/src/main/resources/db/migration/` |
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
| NoSQL Repositories | `NoSQLDatastore/src/main/java/.../nosqldatastore/repository/` |
{{- end}}
{{- if .HasModule "Shared"}}
| Services | `Shared/src/main/java/.../shared/service/` |
{{- end}}
{{- if .HasModule "API"}}
| Controllers | `API/src/main/java/.../api/controller/` |
| API Config | `API/src/main/java/.../api/config/` |
{{- end}}
{{- if .HasModule "Worker"}}
| Job Handlers | `Worker/src/main/java/.../worker/handler/` |
{{- end}}
{{- if .HasModule "EventConsumer"}}
| Event Listeners | `EventConsumer/src/main/java/.../eventconsumer/listener/` |
{{- end}}
<!-- AI:FILES:END -->

## Immutables

This project uses [Immutables](https://immutables.github.io/) for all DTOs and entities. This is a critical pattern — Claude must follow it.

**Rules:**
- Always use `ImmutableX` concrete types in method signatures, not interface types
- Always use builders: `ImmutablePlaceholder.builder()...build()`
- Never use `new` for Immutable objects
- Always add `@JsonSerialize` and `@JsonDeserialize` annotations
- Enums do NOT use Immutables

**Correct:**
```java
public ImmutablePlaceholder create(ImmutablePlaceholderRequest request) {
    return ImmutablePlaceholder.builder()
        .name(request.name())
        .build();
}
```

**Wrong:**
```java
public Placeholder create(PlaceholderRequest request) {  // interface type
    return new Placeholder(...);  // constructor
}
```
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}

## Persistence Boundaries
{{- if .HasModule "SQLDatastore"}}

**SQL (Spring Data JDBC):**
- `PlaceholderRecord` (Java record) exists only at repository boundary
- Convert to `ImmutablePlaceholder` immediately after repository calls
- Never expose `PlaceholderRecord` outside repository/service layer
- Flyway migrations: `V{number}__{description}.sql` — never modify existing migrations
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}

**NoSQL ({{if eq .NoSQLDatabase "mongodb"}}MongoDB{{else if eq .NoSQLDatabase "redis"}}Redis{{end}}):**
- `PlaceholderDocument` (Java record) exists only at repository boundary
- Convert to `ImmutablePlaceholder` immediately after repository calls
- Never expose `PlaceholderDocument` outside repository/service layer
{{- if eq .NoSQLDatabase "mongodb"}}
- MongoDB auto-generates `_id` when `id` is null on save
{{- else if eq .NoSQLDatabase "redis"}}
- Redis auto-generates `id` when null on save (uses UUID)
{{- end}}
{{- end}}
{{- end}}
{{- if .HasModule "API"}}

## Exception Handling

`GlobalExceptionHandler` handles all common exceptions — do not add try-catch in controllers for:
- Validation errors (400)
- JSON parsing errors (400)
- Missing/mistyped parameters (400)
- Not found (404)
- Method not allowed (405)
- Unsupported media type (415)
- Uncaught exceptions (500)
{{- end}}
{{- if .HasModule "Worker"}}

## Background Jobs (JobRunr)

**Architecture:**
- `Jobs` module contains `JobRequest` records (data contracts)
- `Worker` module contains `JobRequestHandler` implementations
- Any module can enqueue jobs by depending on Jobs module
- Handler class name must be `{RequestName}Handler`

**Enqueueing jobs:**
```java
// Fire-and-forget
BackgroundJobRequest.enqueue(new ProcessPlaceholderJobRequest("data"));

// Delayed
BackgroundJobRequest.schedule(Instant.now().plus(1, ChronoUnit.HOURS),
    new ProcessPlaceholderJobRequest("data"));

// Batch
BackgroundJobRequest.enqueue(requests.stream());
```

**Recurring jobs:** Register in `RecurringJobsConfig` using `jobScheduler.scheduleRecurrently()`

**Handler requirements:**
- Annotate with `@Job(name = "Descriptive name: %0")`
- Keep handlers idempotent (they retry on failure)

**Ports:**
- 8081 — Worker application
- 8082 — Management/actuator (health checks use this port, not 8081)
- 8000 — JobRunr Dashboard (no auth by default — disable in production)
{{- end}}
{{- if .HasModule "EventConsumer"}}

## Event-Driven Processing ({{if .UsesKafka}}Kafka{{else if .UsesRabbitMQ}}RabbitMQ{{else if .UsesSQS}}AWS SQS{{else if .UsesPubSub}}GCP Pub/Sub{{end}})

**Architecture:**
- `Events` module contains sealed interfaces for event contracts and `EventPublisher` service
- `EventConsumer` module contains event listeners
- API/Shared modules depend on Events to publish events

**Event contracts (Events module):**
```java
public sealed interface PlaceholderEvent
    permits PlaceholderCreatedEvent {
    String eventId();
    Instant occurredAt();
}
```

**Publishing events (from API or other modules):**
```java
@Autowired
private EventPublisher eventPublisher;

eventPublisher.publish(PlaceholderCreatedEvent.create("123", "name"));
```

**Listener pattern:**
{{- if .UsesKafka}}
- Use `@RetryableTopic` with DLT suffix for dead letter queue
- Use `@KafkaListener` with topics from `${app.kafka.topics.xxx}`
{{- else if .UsesRabbitMQ}}
- Use `@RabbitListener` with queue names from `${app.rabbitmq.queues.xxx}`
- Dead letter exchange is configured automatically with `.dlx` suffix
{{- else if .UsesSQS}}
- Use `@SqsListener` with queue names from `${app.sqs.queue.xxx}`
- Configure Dead Letter Queue (DLQ) in AWS Console for failed messages
- Use `Acknowledgement` parameter for manual message acknowledgment
{{- else if .UsesPubSub}}
- Use `@ServiceActivator(inputChannel = "xxxInputChannel")` for message handling
- Pub/Sub uses Spring Integration channels configured in `PubSubConfig`
- Use `BasicAcknowledgeablePubsubMessage` for manual ack/nack
{{- end}}

**Ports:**
- 8083 — EventConsumer application
- 8084 — Management/actuator (health checks use this port, not 8083)
{{- end}}

## Configuration
{{- if or (or (.HasModule "API") (.HasModule "Worker")) (.HasModule "EventConsumer")}}

- Use `${ENV_VAR:default}` pattern in `application.yml` — never hardcode credentials
- Log format is in `logback-spring.xml`, log levels are in `application.yml` — do not mix these
- Default profile is `local` (colored console); other profiles use JSON logging
{{- end}}
{{- if .HasModule "Shared"}}
- Use `@CircuitBreaker(name = "default")` on methods calling external resources
{{- end}}
{{- if .HasModule "API"}}

## Observability

**Metrics (Prometheus):**
- All modules expose metrics at `/actuator/prometheus`
- Metrics configuration is in `application.yml` under `management.metrics`

**API Documentation (OpenAPI/Swagger):**
- Swagger UI: `http://localhost:8080/swagger-ui.html`
- OpenAPI spec: `http://localhost:8080/api-docs`
- Configuration in `OpenAPIConfig.java` and `application.yml` under `springdoc`
- Disable with `SPRINGDOC_ENABLED=false`

**Correlation IDs:**
- `CorrelationIdFilter.java` adds `X-Correlation-ID` header to all requests
- IDs are included in logs via MDC and returned in response headers
- Pass existing ID in request header for distributed tracing

**Health Probes:**
- `/actuator/health` — Overall health
- `/actuator/health/readiness` — Kubernetes readiness
- `/actuator/health/liveness` — Kubernetes liveness

**Test Coverage:**
- JaCoCo reports at `<module>/target/site/jacoco/index.html` after `mvn test`
{{- end}}
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}

## Testing

Repository tests use Testcontainers — Docker must be running.
{{- end}}

## Task Guides

For complex tasks, read the corresponding guide in `.ai/prompts/`:

| Task | Guide | When to Use |
|------|-------|-------------|
| Add new entity | `.ai/prompts/add-entity.md` | Creating a new domain object |
{{- if .HasModule "API"}}
| Add REST endpoint | `.ai/prompts/add-endpoint.md` | Exposing new API functionality |
{{- end}}
{{- if .HasModule "Worker"}}
| Add background job | `.ai/prompts/add-job.md` | Async processing tasks |
{{- end}}
{{- if .HasModule "EventConsumer"}}
| Add event type | `.ai/prompts/add-event.md` | Event-driven features |
{{- end}}

<!-- AI:CHECKPOINT:START -->
## Session Status

**Branch**: (not tracked yet)
**Working on**: (no active task)
**Tests**: (not run yet)

_Update `.ai/checkpoint.json` to track progress across sessions._
<!-- AI:CHECKPOINT:END -->

## Git

These files are local and already in `.gitignore`:
- `CLAUDE.local.md`, `.claude/settings.local.json` — personal Claude Code settings
- `*PLAN.md` — plan mode scratch files
