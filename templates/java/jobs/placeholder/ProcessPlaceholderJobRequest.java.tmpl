package {{.GroupID}}.jobs.placeholder;

import org.jobrunr.jobs.lambdas.JobRequestHandler;

/**
 * Job request for processing a placeholder entity.
 *
 * This request can be enqueued from any module that depends on Jobs:
 *
 * <pre>
 * // Fire-and-forget (immediate background execution)
 * BackgroundJobRequest.enqueue(new ProcessPlaceholderJobRequest("process this"));
 *
 * // Delayed (execute at specific time)
 * BackgroundJobRequest.schedule(
 *     Instant.now().plusHours(1),
 *     new ProcessPlaceholderJobRequest("process later")
 * );
 *
 * // Batch (process multiple items)
 * List&lt;ProcessPlaceholderJobRequest&gt; requests = items.stream()
 *     .map(ProcessPlaceholderJobRequest::new)
 *     .toList();
 * BackgroundJobRequest.enqueue(requests.stream());
 * </pre>
 *
 * The handler (ProcessPlaceholderJobRequestHandler) lives in the Worker module.
 *
 * @param message The message to process
 */
public record ProcessPlaceholderJobRequest(String message) implements PlaceholderJobRequest {

    private static final String HANDLER_CLASS = "{{.GroupID}}.worker.handler.ProcessPlaceholderJobRequestHandler";

    /**
     * Returns the handler class for this job request.
     * Uses Class.forName() for runtime lookup to avoid compile-time dependency on Worker module.
     */
    @Override
    @SuppressWarnings("unchecked")
    public Class<? extends JobRequestHandler<ProcessPlaceholderJobRequest>> getJobRequestHandler() {
        try {
            return (Class<? extends JobRequestHandler<ProcessPlaceholderJobRequest>>) Class.forName(HANDLER_CLASS);
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(
                "Handler class not found: " + HANDLER_CLASS + ". Ensure Worker module is on the classpath.", e);
        }
    }
}
