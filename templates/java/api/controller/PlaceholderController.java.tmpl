package {{.GroupID}}.api.controller;

import {{.GroupID}}.model.dto.ImmutablePlaceholderRequest;
import {{.GroupID}}.model.dto.ImmutablePlaceholderResponse;
{{- if .HasModule "Shared"}}
import {{.GroupID}}.shared.service.PlaceholderService;
{{- else if .HasModule "SQLDatastore"}}
import {{.GroupID}}.model.entities.ImmutablePlaceholder;
import {{.GroupID}}.model.entities.PlaceholderRecord;
import {{.GroupID}}.sqldatastore.repository.PlaceholderRepository;
import java.time.Instant;
import java.util.stream.StreamSupport;
{{- end}}
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller for Placeholder CRUD operations.
 *
 * Always uses ImmutableX types with builder pattern.
 * Replace this with your actual controllers.
 */
@RestController
@RequestMapping("/api/placeholders")
public class PlaceholderController {

{{- if .HasModule "Shared"}}
    private final PlaceholderService service;

    public PlaceholderController(PlaceholderService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<ImmutablePlaceholderResponse> create(@Valid @RequestBody ImmutablePlaceholderRequest request) {
        var created = service.create(request);
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ImmutablePlaceholderResponse.builder()
                .id(created.id())
                .name(created.name())
                .description(created.description())
                .createdAt(created.createdAt())
                .updatedAt(created.updatedAt())
                .build());
    }

    @GetMapping("/{id}")
    public ResponseEntity<ImmutablePlaceholderResponse> getById(@PathVariable Long id) {
        return service.findById(id)
            .map(p -> ResponseEntity.ok(ImmutablePlaceholderResponse.builder()
                .id(p.id())
                .name(p.name())
                .description(p.description())
                .createdAt(p.createdAt())
                .updatedAt(p.updatedAt())
                .build()))
            .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping
    public ResponseEntity<List<ImmutablePlaceholderResponse>> getAll() {
        var placeholders = service.findAll().stream()
            .map(p -> ImmutablePlaceholderResponse.builder()
                .id(p.id())
                .name(p.name())
                .description(p.description())
                .createdAt(p.createdAt())
                .updatedAt(p.updatedAt())
                .build())
            .toList();
        return ResponseEntity.ok(placeholders);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ImmutablePlaceholderResponse> update(
            @PathVariable Long id,
            @Valid @RequestBody ImmutablePlaceholderRequest request) {
        return service.update(id, request)
            .map(p -> ResponseEntity.ok(ImmutablePlaceholderResponse.builder()
                .id(p.id())
                .name(p.name())
                .description(p.description())
                .createdAt(p.createdAt())
                .updatedAt(p.updatedAt())
                .build()))
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        if (service.delete(id)) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }
{{- else if .HasModule "SQLDatastore"}}
    // Using repository directly (Shared module not included)
    private final PlaceholderRepository repository;

    public PlaceholderController(PlaceholderRepository repository) {
        this.repository = repository;
    }

    @PostMapping
    public ResponseEntity<ImmutablePlaceholderResponse> create(@Valid @RequestBody ImmutablePlaceholderRequest request) {
        var saved = repository.save(new PlaceholderRecord(
            request.name(), request.description(), Instant.now()
        ));
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ImmutablePlaceholderResponse.builder()
                .id(saved.id())
                .name(saved.name())
                .description(saved.description())
                .createdAt(saved.createdAt())
                .updatedAt(saved.updatedAt())
                .build());
    }

    @GetMapping("/{id}")
    public ResponseEntity<ImmutablePlaceholderResponse> getById(@PathVariable Long id) {
        return repository.findById(id)
            .map(record -> ResponseEntity.ok(ImmutablePlaceholderResponse.builder()
                .id(record.id())
                .name(record.name())
                .description(record.description())
                .createdAt(record.createdAt())
                .updatedAt(record.updatedAt())
                .build()))
            .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping
    public ResponseEntity<List<ImmutablePlaceholderResponse>> getAll() {
        var placeholders = StreamSupport.stream(repository.findAll().spliterator(), false)
            .map(record -> ImmutablePlaceholderResponse.builder()
                .id(record.id())
                .name(record.name())
                .description(record.description())
                .createdAt(record.createdAt())
                .updatedAt(record.updatedAt())
                .build())
            .toList();
        return ResponseEntity.ok(placeholders);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ImmutablePlaceholderResponse> update(
            @PathVariable Long id,
            @Valid @RequestBody ImmutablePlaceholderRequest request) {
        return repository.findById(id)
            .map(existing -> {
                var saved = repository.save(existing.withNameAndDescription(
                    request.name(), request.description()
                ));
                return ResponseEntity.ok(ImmutablePlaceholderResponse.builder()
                    .id(saved.id())
                    .name(saved.name())
                    .description(saved.description())
                    .createdAt(saved.createdAt())
                    .updatedAt(saved.updatedAt())
                    .build());
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        if (repository.existsById(id)) {
            repository.deleteById(id);
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.notFound().build();
    }
{{- else}}
    // TODO: Neither Shared nor SQLDatastore modules included.
    // Add at least SQLDatastore module for database access.

    @PostMapping
    public ResponseEntity<String> create(@Valid @RequestBody ImmutablePlaceholderRequest request) {
        return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED)
            .body("SQLDatastore or Shared module required");
    }

    @GetMapping("/{id}")
    public ResponseEntity<String> getById(@PathVariable Long id) {
        return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED)
            .body("SQLDatastore or Shared module required");
    }

    @GetMapping
    public ResponseEntity<String> getAll() {
        return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED)
            .body("SQLDatastore or Shared module required");
    }

    @PutMapping("/{id}")
    public ResponseEntity<String> update(@PathVariable Long id, @Valid @RequestBody ImmutablePlaceholderRequest request) {
        return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED)
            .body("SQLDatastore or Shared module required");
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<String> delete(@PathVariable Long id) {
        return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED)
            .body("SQLDatastore or Shared module required");
    }
{{- end}}
}
