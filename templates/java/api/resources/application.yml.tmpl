server:
  port: ${SERVER_PORT:8080}

spring:
  application:
    name: {{.ProjectName}}-api
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:local}
{{- if .HasModule "SQLDatastore"}}

  # Database configuration
  # Default ports use 5433 (PostgreSQL) or 3307 (MySQL) to avoid conflicts with local installations
  # Use docker-compose up -d to start the database container
  datasource:
{{- if eq .Database "postgresql"}}
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5433}/${DB_NAME:{{.ProjectName}}}?sslmode=${DB_SSL_MODE:prefer}
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:postgres}
    driver-class-name: org.postgresql.Driver
{{- else if eq .Database "mysql"}}
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3307}/${DB_NAME:{{.ProjectName}}}?useSSL=${DB_USE_SSL:true}&requireSSL=${DB_REQUIRE_SSL:false}&verifyServerCertificate=${DB_VERIFY_CERT:false}
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:root}
    driver-class-name: com.mysql.cj.jdbc.Driver
{{- else}}
    url: jdbc:h2:mem:{{.ProjectName}};DB_CLOSE_DELAY=-1
    username: ${DB_USERNAME:sa}
    password: ${DB_PASSWORD:}
    driver-class-name: org.h2.Driver
{{- end}}
    hikari:
      pool-name: {{.ProjectNamePascal}}Pool
      maximum-pool-size: ${DB_POOL_SIZE:10}
      minimum-idle: ${DB_POOL_MIN_IDLE:3}
      connection-timeout: 20000
      idle-timeout: 300000
      max-lifetime: 1200000

  # Flyway migrations
  flyway:
    enabled: ${FLYWAY_ENABLED:true}
    locations: classpath:db/migration
    baseline-on-migrate: true
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
{{- if eq .NoSQLDatabase "mongodb"}}

  # MongoDB configuration
  # Use docker-compose up -d to start the MongoDB container
  data:
    mongodb:
      uri: ${MONGODB_URI:mongodb://localhost:27017/{{.ProjectName}}}
      auto-index-creation: true
{{- else if eq .NoSQLDatabase "redis"}}

  # Redis configuration
  # Use docker-compose up -d to start the Redis container
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
{{- end}}
{{- end}}
{{- if and (.HasModule "Worker") (and (not (.HasModule "SQLDatastore")) (.JobRunrUsesSql))}}

  # PostgreSQL datasource for JobRunr job storage (enqueue-only)
  # This is needed because no SQLDatastore module is selected.
  # Use docker-compose up -d to start the database container.
  datasource:
    url: jdbc:postgresql://localhost:5434/{{.ProjectName}}_jobs
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 5
      minimum-idle: 2
      connection-timeout: 30000
{{- end}}
{{- if and (.HasModule "EventConsumer") (.UsesKafka)}}

  # Kafka Configuration (for event publishing)
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
{{- else if and (.HasModule "EventConsumer") (.UsesRabbitMQ)}}

  # RabbitMQ Configuration (for event publishing)
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}
    virtual-host: ${RABBITMQ_VHOST:/}
{{- end}}
{{- if .HasModule "Shared"}}

# Resilience4j configuration
resilience4j:
  circuitbreaker:
    instances:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3
{{- end}}

# CORS configuration
# SECURITY: Restrict allowed-origins to your actual domains in production
cors:
  allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:8080}
  allowed-methods: ${CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS}
  allowed-headers: ${CORS_ALLOWED_HEADERS:Content-Type,Authorization,X-Requested-With}
  allow-credentials: ${CORS_ALLOW_CREDENTIALS:false}
  max-age: ${CORS_MAX_AGE:3600}

# Security headers configuration
# SECURITY: These headers help protect against common web vulnerabilities
security:
  headers:
    enabled: ${SECURITY_HEADERS_ENABLED:true}
    content-security-policy: ${CSP:default-src 'self'}
    x-frame-options: ${X_FRAME_OPTIONS:DENY}
    x-content-type-options: ${X_CONTENT_TYPE_OPTIONS:nosniff}
    x-xss-protection: ${X_XSS_PROTECTION:1; mode=block}
    referrer-policy: ${REFERRER_POLICY:strict-origin-when-cross-origin}
    permissions-policy: ${PERMISSIONS_POLICY:geolocation=(), microphone=(), camera=()}

# Actuator endpoints
# SECURITY: In production, consider restricting to health only or securing with authentication
management:
  endpoints:
    web:
      exposure:
        include: ${MANAGEMENT_ENDPOINTS:health,info}
      base-path: /actuator
  endpoint:
    health:
      show-details: ${MANAGEMENT_HEALTH_DETAILS:when_authorized}
      show-components: ${MANAGEMENT_HEALTH_COMPONENTS:when_authorized}
  info:
    env:
      enabled: false

{{- if .HasModule "Worker"}}
# JobRunr Configuration (enqueue-only â€” background server runs in the Worker module)
jobrunr:
  background-job-server:
    enabled: false
  dashboard:
    enabled: false
  database:
    skip-create: false
{{- if .JobRunrUsesSql}}
    type: sql
{{- else if .JobRunrUsesMongoDB}}
    type: mongodb
{{- end}}
{{- end}}
{{- if and (.HasModule "EventConsumer") (.UsesKafka)}}

# Kafka topic configuration
app:
  kafka:
    topics:
      placeholder-events: ${KAFKA_TOPIC_PLACEHOLDER:placeholder-events}
{{- else if and (.HasModule "EventConsumer") (.UsesRabbitMQ)}}

# RabbitMQ exchange configuration
app:
  rabbitmq:
    exchanges:
      placeholder: ${RABBITMQ_EXCHANGE_PLACEHOLDER:placeholder-exchange}
{{- end}}

# Logging
logging:
  level:
    {{.GroupID}}: ${LOG_LEVEL:DEBUG}
    org.springframework.web: INFO
    org.springframework.security: INFO
    root: INFO
