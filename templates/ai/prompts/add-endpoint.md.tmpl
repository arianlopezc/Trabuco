# Add REST Endpoint

## Overview

Create a new REST API endpoint with proper request/response handling, validation, and error handling.

## Prerequisites

- Entity and service already exist (see `add-entity.md` if needed)
- Project compiles successfully (`mvn clean compile`)

## Steps

### 1. Create Request DTO (if not existing)

**File**: `Model/src/main/java/{{.PackagePath}}/model/dto/{EntityName}Request.java`

```java
package {{.GroupID}}.model.dto;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.immutables.value.Value;
import {{.GroupID}}.model.ImmutableStyle;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Value.Immutable
@ImmutableStyle
@JsonSerialize(as = Immutable{EntityName}Request.class)
@JsonDeserialize(as = Immutable{EntityName}Request.class)
public interface {EntityName}Request {
    @NotBlank(message = "Name is required")
    @Size(max = 255, message = "Name must be at most 255 characters")
    String name();
    // Add other fields with validation annotations
}
```

### 2. Create Response DTO (if not existing)

**File**: `Model/src/main/java/{{.PackagePath}}/model/dto/{EntityName}Response.java`

```java
package {{.GroupID}}.model.dto;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.immutables.value.Value;
import {{.GroupID}}.model.ImmutableStyle;
import {{.GroupID}}.model.entities.Immutable{EntityName};

@Value.Immutable
@ImmutableStyle
@JsonSerialize(as = Immutable{EntityName}Response.class)
@JsonDeserialize(as = Immutable{EntityName}Response.class)
public interface {EntityName}Response {
    String id();
    String name();

    static Immutable{EntityName}Response from(Immutable{EntityName} entity) {
        return Immutable{EntityName}Response.builder()
            .id(entity.id())
            .name(entity.name())
            .build();
    }
}
```

### 3. Create or Update Controller

**File**: `API/src/main/java/{{.PackagePath}}/api/controller/{EntityName}Controller.java`

```java
package {{.GroupID}}.api.controller;

import {{.GroupID}}.model.dto.Immutable{EntityName}Request;
import {{.GroupID}}.model.dto.Immutable{EntityName}Response;
import {{.GroupID}}.model.entities.Immutable{EntityName};
import {{.GroupID}}.shared.service.{EntityName}Service;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/{entities}")
public class {EntityName}Controller {

    private final {EntityName}Service service;

    public {EntityName}Controller({EntityName}Service service) {
        this.service = service;
    }

    @GetMapping
    public List<Immutable{EntityName}Response> getAll() {
        return service.findAll().stream()
            .map(Immutable{EntityName}Response::from)
            .toList();
    }

    @GetMapping("/{id}")
    public ResponseEntity<Immutable{EntityName}Response> getById(@PathVariable {{if .HasModule "SQLDatastore"}}Long{{else}}String{{end}} id) {
        return service.findById(id)
            .map(entity -> ResponseEntity.ok(Immutable{EntityName}Response.from(entity)))
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Immutable{EntityName}Response create(@Valid @RequestBody Immutable{EntityName}Request request) {
        Immutable{EntityName} entity = Immutable{EntityName}.builder()
            .name(request.name())
            .build();
        Immutable{EntityName} saved = service.save(entity);
        return Immutable{EntityName}Response.from(saved);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Immutable{EntityName}Response> update(
            @PathVariable {{if .HasModule "SQLDatastore"}}Long{{else}}String{{end}} id,
            @Valid @RequestBody Immutable{EntityName}Request request) {
        return service.findById(id)
            .map(existing -> {
                Immutable{EntityName} updated = Immutable{EntityName}.builder()
                    .id(existing.id())
                    .name(request.name())
                    .build();
                Immutable{EntityName} saved = service.save(updated);
                return ResponseEntity.ok(Immutable{EntityName}Response.from(saved));
            })
            .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable {{if .HasModule "SQLDatastore"}}Long{{else}}String{{end}} id) {
        return service.findById(id)
            .map(entity -> {
                service.deleteById(id);
                return ResponseEntity.noContent().<Void>build();
            })
            .orElse(ResponseEntity.notFound().build());
    }
}
```

**Replace placeholders:**
- `{EntityName}` → Actual entity name (PascalCase)
- `{entities}` → Plural form, lowercase (e.g., `products`, `orders`)

### 4. Update Service (if delete method needed)

Add to the existing service class:

```java
public void deleteById({{if .HasModule "SQLDatastore"}}Long{{else}}String{{end}} id) {
    repository.deleteById(id);
}
```

### 5. Write Controller Tests

Write tests one at a time. For each test: write the failing test first, implement the minimum code to make it pass.

**File**: `API/src/test/java/{{.PackagePath}}/api/controller/{EntityName}ControllerTest.java`

```java
package {{.GroupID}}.api.controller;

import {{.GroupID}}.model.entities.Immutable{EntityName};
import {{.GroupID}}.shared.service.{EntityName}Service;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.bean.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Optional;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest({EntityName}Controller.class)
class {EntityName}ControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private {EntityName}Service service;

    @Test
    void should_Return201_When_CreatingValidEntity() throws Exception {
        // Given
        var created = Immutable{EntityName}.builder()
            .id("1").name("Test").build();
        when(service.save(any())).thenReturn(created);

        // When/Then
        mockMvc.perform(post("/api/{entities}")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"name\": \"Test\"}"))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.name").value("Test"));
    }

    @Test
    void should_Return400_When_NameIsBlank() throws Exception {
        mockMvc.perform(post("/api/{entities}")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"name\": \"\"}"))
            .andExpect(status().isBadRequest());
    }

    @Test
    void should_Return404_When_EntityNotFound() throws Exception {
        // Given
{{- if .HasModule "SQLDatastore"}}
        when(service.findById(999L)).thenReturn(Optional.empty());
{{- else}}
        when(service.findById("999")).thenReturn(Optional.empty());
{{- end}}

        // When/Then
        mockMvc.perform(get("/api/{entities}/999"))
            .andExpect(status().isNotFound());
    }

    @Test
    void should_Return204_When_DeletingExistingEntity() throws Exception {
        // Given
{{- if .HasModule "SQLDatastore"}}
        when(service.findById(1L)).thenReturn(Optional.of(
            Immutable{EntityName}.builder().id("1").name("Test").build()));
{{- else}}
        when(service.findById("1")).thenReturn(Optional.of(
            Immutable{EntityName}.builder().id("1").name("Test").build()));
{{- end}}

        // When/Then
        mockMvc.perform(delete("/api/{entities}/1"))
            .andExpect(status().isNoContent());
    }
}
```

### 6. Test the Endpoint

```bash
# Compile and run tests
mvn clean compile
mvn test

# Start API
cd API && mvn spring-boot:run

# Test endpoints
curl http://localhost:8080/api/{entities}
curl -X POST http://localhost:8080/api/{entities} \
  -H "Content-Type: application/json" \
  -d '{"name": "Test"}'
```

### 7. Check OpenAPI Documentation

After starting the API:
- Open http://localhost:8080/swagger-ui.html
- Verify the new endpoint appears with correct request/response schemas

## Checklist

- [ ] Request DTO created with validation annotations
- [ ] Response DTO created with `from()` factory method
- [ ] Controller created with proper annotations
- [ ] All methods use `Immutable` types (not interfaces)
- [ ] Validation enabled with `@Valid`
- [ ] Proper HTTP status codes (201 for create, 204 for delete)
- [ ] Controller tests written (201, 400, 404, 204)
- [ ] Code compiles (`mvn clean compile`)
- [ ] Tests pass (`mvn test`)
- [ ] Endpoint works (test with curl or Swagger UI)
- [ ] Shows in Swagger UI correctly

## Common Mistakes

- **Using interface types**: Use `Immutable{EntityName}Request` not `{EntityName}Request`
- **Missing `@Valid`**: Required for validation annotations to work
- **Wrong HTTP methods**: POST for create, PUT for full update, PATCH for partial
- **Exposing entities directly**: Always use Response DTOs, never return entities
- **Manual exception handling**: Let `GlobalExceptionHandler` handle common cases
- **Hardcoded paths**: Use `@PathVariable` and `@RequestParam` appropriately

## Advanced: Pagination

For list endpoints with many records:

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

@GetMapping
public Page<Immutable{EntityName}Response> getAll(Pageable pageable) {
    return service.findAll(pageable)
        .map(Immutable{EntityName}Response::from);
}
```

Requires updating repository and service to support `Pageable`.
