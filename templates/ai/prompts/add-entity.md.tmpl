# Add New Entity

## Overview

Create a new domain entity with all required layers: entity definition, repository, service, and optionally a REST endpoint.

## Prerequisites

- Project compiles successfully (`mvn clean compile`)
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}
- Docker running (for repository tests with Testcontainers)
{{- end}}

## Steps

### 1. Create the Entity Interface

**File**: `Model/src/main/java/{{.PackagePath}}/model/entities/{EntityName}.java`

```java
package {{.GroupID}}.model.entities;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.immutables.value.Value;
import {{.GroupID}}.model.ImmutableStyle;
import org.jspecify.annotations.Nullable;

@Value.Immutable
@ImmutableStyle
@JsonSerialize(as = Immutable{EntityName}.class)
@JsonDeserialize(as = Immutable{EntityName}.class)
public interface {EntityName} {
    @Nullable
    String id();

    String name();
    // Add other fields as needed
}
```

**Important:**
- Replace `{EntityName}` with actual name (e.g., `Product`, `Order`)
- Always use `@Nullable` for optional fields
- Always add `@JsonSerialize` and `@JsonDeserialize` annotations
{{- if .HasModule "SQLDatastore"}}

### 2a. Create SQL Record (if using SQLDatastore)

**File**: `Model/src/main/java/{{.PackagePath}}/model/entities/{EntityName}Record.java`

```java
package {{.GroupID}}.model.entities;

import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

@Table("{entity_name_snake}")
public record {EntityName}Record(
    @Id Long id,
    String name
    // Add other fields matching the entity
) {
    public static {EntityName}Record fromEntity(Immutable{EntityName} entity) {
        return new {EntityName}Record(
            entity.id() != null ? Long.valueOf(entity.id()) : null,
            entity.name()
        );
    }

    public Immutable{EntityName} toEntity() {
        return Immutable{EntityName}.builder()
            .id(String.valueOf(id))
            .name(name)
            .build();
    }
}
```

### 2b. Create SQL Migration

**File**: `SQLDatastore/src/main/resources/db/migration/V{next_version}__{description}.sql`

```sql
CREATE TABLE {entity_name_snake} (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Important:**
- Find the next version number by checking existing migrations
- Never modify existing migration files
- Use snake_case for table and column names

### 2c. Create SQL Repository

**File**: `SQLDatastore/src/main/java/{{.PackagePath}}/sqldatastore/repository/{EntityName}Repository.java`

```java
package {{.GroupID}}.sqldatastore.repository;

import {{.GroupID}}.model.entities.{EntityName}Record;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface {EntityName}Repository extends CrudRepository<{EntityName}Record, Long> {
    // Add custom query methods as needed
}
```
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}

### 2a. Create NoSQL Document (if using NoSQLDatastore)

**File**: `Model/src/main/java/{{.PackagePath}}/model/entities/{EntityName}Document.java`

{{- if eq .NoSQLDatabase "mongodb"}}
```java
package {{.GroupID}}.model.entities;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Document(collection = "{entity_name_snake}")
public record {EntityName}Document(
    @Id String id,
    String name
) {
    public static {EntityName}Document fromEntity(Immutable{EntityName} entity) {
        return new {EntityName}Document(entity.id(), entity.name());
    }

    public Immutable{EntityName} toEntity() {
        return Immutable{EntityName}.builder()
            .id(id)
            .name(name)
            .build();
    }
}
```
{{- else if eq .NoSQLDatabase "redis"}}
```java
package {{.GroupID}}.model.entities;

import org.springframework.data.annotation.Id;
import org.springframework.data.redis.core.RedisHash;

@RedisHash("{entity_name_snake}")
public record {EntityName}Document(
    @Id String id,
    String name
) {
    public static {EntityName}Document fromEntity(Immutable{EntityName} entity) {
        return new {EntityName}Document(entity.id(), entity.name());
    }

    public Immutable{EntityName} toEntity() {
        return Immutable{EntityName}.builder()
            .id(id)
            .name(name)
            .build();
    }
}
```
{{- end}}

### 2b. Create NoSQL Repository

**File**: `NoSQLDatastore/src/main/java/{{.PackagePath}}/nosqldatastore/repository/{EntityName}DocumentRepository.java`

{{- if eq .NoSQLDatabase "mongodb"}}
```java
package {{.GroupID}}.nosqldatastore.repository;

import {{.GroupID}}.model.entities.{EntityName}Document;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface {EntityName}DocumentRepository extends MongoRepository<{EntityName}Document, String> {
}
```
{{- else if eq .NoSQLDatabase "redis"}}
```java
package {{.GroupID}}.nosqldatastore.repository;

import {{.GroupID}}.model.entities.{EntityName}Document;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface {EntityName}DocumentRepository extends CrudRepository<{EntityName}Document, String> {
}
```
{{- end}}
{{- end}}
{{- if .HasModule "Shared"}}

### 3. Create Service

**File**: `Shared/src/main/java/{{.PackagePath}}/shared/service/{EntityName}Service.java`

```java
package {{.GroupID}}.shared.service;

import {{.GroupID}}.model.entities.Immutable{EntityName};
{{- if .HasModule "SQLDatastore"}}
import {{.GroupID}}.model.entities.{EntityName}Record;
import {{.GroupID}}.sqldatastore.repository.{EntityName}Repository;
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
import {{.GroupID}}.model.entities.{EntityName}Document;
import {{.GroupID}}.nosqldatastore.repository.{EntityName}DocumentRepository;
{{- end}}
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;
import java.util.stream.StreamSupport;

@Service
public class {EntityName}Service {

{{- if .HasModule "SQLDatastore"}}
    private final {EntityName}Repository repository;

    public {EntityName}Service({EntityName}Repository repository) {
        this.repository = repository;
    }

    public List<Immutable{EntityName}> findAll() {
        return StreamSupport.stream(repository.findAll().spliterator(), false)
            .map({EntityName}Record::toEntity)
            .toList();
    }

    public Optional<Immutable{EntityName}> findById(Long id) {
        return repository.findById(id).map({EntityName}Record::toEntity);
    }

    public Immutable{EntityName} save(Immutable{EntityName} entity) {
        {EntityName}Record saved = repository.save({EntityName}Record.fromEntity(entity));
        return saved.toEntity();
    }
{{- else if .HasModule "NoSQLDatastore"}}
    private final {EntityName}DocumentRepository repository;

    public {EntityName}Service({EntityName}DocumentRepository repository) {
        this.repository = repository;
    }

    public List<Immutable{EntityName}> findAll() {
        return repository.findAll().stream()
            .map({EntityName}Document::toEntity)
            .toList();
    }

    public Optional<Immutable{EntityName}> findById(String id) {
        return repository.findById(id).map({EntityName}Document::toEntity);
    }

    public Immutable{EntityName} save(Immutable{EntityName} entity) {
        {EntityName}Document saved = repository.save({EntityName}Document.fromEntity(entity));
        return saved.toEntity();
    }
{{- end}}
}
```
{{- end}}

### 4. Create Request/Response DTOs (if API needed)

**File**: `Model/src/main/java/{{.PackagePath}}/model/dto/{EntityName}Request.java`

```java
package {{.GroupID}}.model.dto;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.immutables.value.Value;
import {{.GroupID}}.model.ImmutableStyle;

@Value.Immutable
@ImmutableStyle
@JsonSerialize(as = Immutable{EntityName}Request.class)
@JsonDeserialize(as = Immutable{EntityName}Request.class)
public interface {EntityName}Request {
    String name();
    // Add other input fields
}
```

**File**: `Model/src/main/java/{{.PackagePath}}/model/dto/{EntityName}Response.java`

```java
package {{.GroupID}}.model.dto;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import org.immutables.value.Value;
import {{.GroupID}}.model.ImmutableStyle;
import {{.GroupID}}.model.entities.Immutable{EntityName};

@Value.Immutable
@ImmutableStyle
@JsonSerialize(as = Immutable{EntityName}Response.class)
@JsonDeserialize(as = Immutable{EntityName}Response.class)
public interface {EntityName}Response {
    String id();
    String name();
    // Add other output fields

    static Immutable{EntityName}Response from(Immutable{EntityName} entity) {
        return Immutable{EntityName}Response.builder()
            .id(entity.id())
            .name(entity.name())
            .build();
    }
}
```

### 5. Write Tests (Before Finalizing Implementation)

Write tests one at a time using TDD. For each test: write the failing test first, then implement the minimum code to make it pass.
{{- if .HasModule "Shared"}}

**Service unit tests** (`Shared/src/test/java/{{.PackagePath}}/shared/service/{EntityName}ServiceTest.java`):

```java
package {{.GroupID}}.shared.service;

import {{.GroupID}}.model.entities.Immutable{EntityName};
{{- if .HasModule "SQLDatastore"}}
import {{.GroupID}}.model.entities.{EntityName}Record;
import {{.GroupID}}.sqldatastore.repository.{EntityName}Repository;
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
import {{.GroupID}}.model.entities.{EntityName}Document;
import {{.GroupID}}.nosqldatastore.repository.{EntityName}DocumentRepository;
{{- end}}
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class {EntityName}ServiceTest {

    @Mock
{{- if .HasModule "SQLDatastore"}}
    private {EntityName}Repository repository;
{{- else if .HasModule "NoSQLDatastore"}}
    private {EntityName}DocumentRepository repository;
{{- end}}

    @InjectMocks
    private {EntityName}Service service;

    @Test
    void should_ReturnEntity_When_IdExists() {
        // Given
{{- if .HasModule "SQLDatastore"}}
        var record = new {EntityName}Record(1L, "Test");
        when(repository.findById(1L)).thenReturn(Optional.of(record));
{{- else if .HasModule "NoSQLDatastore"}}
        var document = new {EntityName}Document("1", "Test");
        when(repository.findById("1")).thenReturn(Optional.of(document));
{{- end}}

        // When
{{- if .HasModule "SQLDatastore"}}
        Optional<Immutable{EntityName}> result = service.findById(1L);
{{- else if .HasModule "NoSQLDatastore"}}
        Optional<Immutable{EntityName}> result = service.findById("1");
{{- end}}

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().name()).isEqualTo("Test");
    }

    @Test
    void should_ReturnEmpty_When_IdDoesNotExist() {
        // Given
{{- if .HasModule "SQLDatastore"}}
        when(repository.findById(999L)).thenReturn(Optional.empty());
{{- else if .HasModule "NoSQLDatastore"}}
        when(repository.findById("999")).thenReturn(Optional.empty());
{{- end}}

        // When
{{- if .HasModule "SQLDatastore"}}
        Optional<Immutable{EntityName}> result = service.findById(999L);
{{- else if .HasModule "NoSQLDatastore"}}
        Optional<Immutable{EntityName}> result = service.findById("999");
{{- end}}

        // Then
        assertThat(result).isEmpty();
    }
}
```
{{- end}}
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}

**Repository integration tests**: See `.ai/prompts/testing-guide.md` for full Testcontainers examples.
{{- end}}

### 6. Compile and Test

```bash
mvn clean compile
mvn test
```

## Checklist

- [ ] Entity interface created with `@Value.Immutable` and JSON annotations
{{- if .HasModule "SQLDatastore"}}
- [ ] SQL Record created with conversion methods
- [ ] Flyway migration added (new version, not modified existing)
- [ ] SQL Repository interface created
{{- end}}
{{- if .HasModule "NoSQLDatastore"}}
- [ ] Document class created with conversion methods
- [ ] NoSQL Repository interface created
{{- end}}
{{- if .HasModule "Shared"}}
- [ ] Service class created with CRUD operations
- [ ] Service unit tests written (happy path + not found)
{{- end}}
{{- if or (.HasModule "SQLDatastore") (.HasModule "NoSQLDatastore")}}
- [ ] Repository integration tests written (if custom queries)
{{- end}}
- [ ] Request/Response DTOs created (if API endpoint needed)
- [ ] Code compiles (`mvn clean compile`)
- [ ] Tests pass (`mvn test`)

## Common Mistakes

- **Using `new` for Immutables**: Always use `ImmutableX.builder()...build()`
- **Interface types in signatures**: Use `ImmutableX` not `X` interface
- **Missing JSON annotations**: Always add both `@JsonSerialize` and `@JsonDeserialize`
- **Modifying existing migrations**: Create new migration file instead
- **Exposing Record/Document types**: Convert at repository boundary, return Immutables
